-- allow only manual savings (from script)

local raid_save_uid
allow_save = false
local save_idx = 1
local mcm_save_amount = 3
			
local mcm_campfire_saves = raid_options_mcm.get_config("campfire_saves")
if mcm_campfire_saves then
	alife_storage_manager.get_state().enable_campfire_mode = true
else
	alife_storage_manager.get_state().enable_campfire_mode = false
end
		
local enable_console_save = false		-- works with mcm_campfire_saves only

local flag_if_died = false

function really_died()
	if ("l10_radar" ~= alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
		flag_if_died = true
	end
end
	
function save_state(m_data)
	if not (m_data.flag_if_died) then
		m_data.flag_if_died = nil
	end
	m_data.flag_if_died = flag_if_died
	
	printf("save_state")
	if not raid_save_uid then			-- first save
		raid_save_uid = math.random(1000) .. "raid" .. math.random()
	end

	m_data.raid_save_uid = raid_save_uid

	if allow_save then
		m_data.raid_save_idx = save_idx
		allow_save = false
		return
	end

	-- without time event current save will not be created yet, so it will delete our manual save
	CreateTimeEvent("raid_check_save_file_e", "raid_check_save_file_a", 0.5, remove_sv)
end

function remove_sv()
	local r_uid = alife_storage_manager.get_state().raid_save_uid

	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$", bit_or(FS.FS_ListFiles, FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()
	flist:Sort(FS.FS_sort_by_modif_down)
	for it = 0, f_cnt - 1 do
		local file_name = flist:GetAt(it):NameFull():sub(0,-6):lower()
		local path = fs:update_path("$game_saves$", '') .. file_name .. ".scoc"
		local f = io.open(path, "rb")
		if (f) then
			local data = f:read("*all")
			f:close()
			if (data) then
				local decoded = alife_storage_manager.decode(data)
				local d_raid_ud = decoded and decoded.raid_save_uid
				-- get last save file that is not allowed to be saved and delete it
				if d_raid_ud and r_uid and d_raid_ud == r_uid then
					if ("l10_radar" ~= alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
						-- saves without campfire mode
						if (not mcm_campfire_saves) then
							printf("! delete file_name: %s.scoc", file_name)
							ui_load_dialog.delete_save_game(file_name)
							break
						end
						
						-- saves with campfire mode
						if (not enable_console_save) and (not bind_campfire.get_nearby_campfire(100)) then
							printf("! delete file_name: %s.scoc", file_name)
							ui_load_dialog.delete_save_game(file_name)
							break
						end
					end
				end
			end
		end
	end

	allow_save = false
	return true
end

function remove_autosv()
	local r_uid = alife_storage_manager.get_state().raid_save_uid

	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$", bit_or(FS.FS_ListFiles, FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()
	flist:Sort(FS.FS_sort_by_modif_down)
	for it = 0, f_cnt - 1 do
		local file_name = flist:GetAt(it):NameFull():sub(0,-6):lower()
		local path = fs:update_path("$game_saves$", '') .. file_name .. ".scoc"
		local f = io.open(path, "rb")
		if (f) then
			local data = f:read("*all")
			f:close()
			if (data) then
				local decoded = alife_storage_manager.decode(data)
				local d_raid_ud = decoded and decoded.raid_save_uid
				-- get last save file that is not allowed to be saved and delete it
				if d_raid_ud and r_uid and d_raid_ud == r_uid then
					-- try to delete autosave
					if string.find(file_name, "autosave") then
						printf("! delete autosave file_name: %s.scoc", file_name)
						ui_load_dialog.delete_save_game(file_name)
						break
					end
				end
			end
		end
	end
	allow_save = false
	return true
end

function load_state(m_data)
	flag_if_died = m_data.flag_if_died or flag_if_died
	m_data.flag_if_died = nil

	raid_save_uid = m_data.raid_save_uid or nil
	save_idx = m_data.raid_save_idx or 1
end

function all_remove_sv()
	--Save game after death
	CreateTimeEvent("raid_custom_save_e_death", "raid_return_home_save_a_death", 1, function()
		flag_if_died = false
		exec_console_cmd("save " .. (user_name() or "Raid") .. " - " .. "after_death")
		return true
	end)

	--remove saves
	CreateTimeEvent("raid_custom_save_death", "raid_return_home_save_death", 2, function()
		local r_uid = alife_storage_manager.get_state().raid_save_uid
		local fs = getFS()
		local flist = fs:file_list_open_ex("$game_saves$", bit_or(FS.FS_ListFiles, FS.FS_RootOnly),"*.scoc")
		local f_cnt = flist:Size()
		flist:Sort(FS.FS_sort_by_modif_down)
		for it = 0, f_cnt - 1 do
			local file_name = flist:GetAt(it):NameFull():sub(0,-6):lower()
			local path = fs:update_path("$game_saves$", '') .. file_name .. ".scoc"
			local f = io.open(path, "rb")
			if (f) then
				local data = f:read("*all")
				f:close()
				if (data) then
					local decoded = alife_storage_manager.decode(data)
					local d_raid_ud = decoded and decoded.raid_save_uid
					-- get last save file that is not allowed to be saved and delete it
					if d_raid_ud and r_uid and d_raid_ud == r_uid then
						if (string.find(file_name, "after_death") == nil) then	
							printf("! delete allsave file_name: %s.scoc", file_name)
							ui_load_dialog.delete_save_game(file_name)
						end
					end
				end
			end
		end
		allow_save = false
		return true
	end)
end

function raid_save(text, delay)
	--If you died, delete all saves. When you returned to the base
	if (alife_storage_manager.get_state().enable_raid_mode == true) and (flag_if_died == true) and ("l10_radar" == alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
		all_remove_sv()
	end
	flag_if_died = false
	
	--Save game
	local str_HardMode = ""
	if (alife_storage_manager.get_state().enable_raid_mode == true) then str_HardMode = " - hard " end	
	CreateTimeEvent("raid_custom_save_e", "raid_return_home_save_a", delay or 2, function(str)
		allow_save = true
		save_idx = save_idx + 1
		if save_idx > mcm_save_amount then
			save_idx = 1
		end
		exec_console_cmd("save " .. (user_name() or "Raid") .. str_HardMode .. " - " .. str .. " - " .. tostring(save_idx))
		return true
	end, text)
end

function on_before_save_input(flags)
	if ((not mcm_campfire_saves) or (bind_campfire.check_no_nearby_campfire()))
	and ("l10_radar" ~= alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
		if (not mcm_campfire_saves) then
			local str = strformat(game.translate_string("st_ui_raid_no_save"),text)
			actor_menu.set_msg(1, str, 4)  
		end
		
		exec_console_cmd("main_menu off")
		flags.ret = true
	end
end

-- disable timed autosaves
function game_autosave_new.actor_on_first_update()
end

function actor_on_first_update()
	on_option_change()

	-- try to delete autosave with this raid uid
	if (raid_save_uid ~= nil) then			-- first save
		CreateTimeEvent("raid_check_save_file_auto", "raid_check_save_file_auto", 1, remove_autosv)
	end
end

function on_option_change()
	if ("l10_radar" == alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then	--can save game
		alife_storage_manager.get_state().enable_campfire_mode = false
	elseif (alife_storage_manager.get_state().enable_raid_mode == true) then   					--can't save game
		alife_storage_manager.get_state().enable_campfire_mode = false
		mcm_campfire_saves = false		
	else																				--depends on mcm settings
		mcm_campfire_saves = raid_options_mcm.get_config("campfire_saves")
		if mcm_campfire_saves then
			alife_storage_manager.get_state().enable_campfire_mode = true
		else
			alife_storage_manager.get_state().enable_campfire_mode = false
		end
	end
end

-- Blocking game loading during raid
function on_before_load_input(t1, t2, flags)
	if (level.present()) then
		if (alife_storage_manager.get_state().enable_raid_mode == true) then
			if ("l10_radar" ~= alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
				local str = strformat(game.translate_string("st_ui_raid_no_load"),text)
				actor_menu.set_msg(1, str, 4) 
				exec_console_cmd("main_menu off")
				flags.ret = true
			end
		end
	end
end

-- Console lock during raid
function on_before_key_press(key, bind, dis, flags)
	if (level.present()) then
		if (alife_storage_manager.get_state().enable_raid_mode == true) then
			if ("l10_radar" ~= alife():level_name(game_graph():vertex(alife():actor().m_game_vertex_id):level_id())) then
			   local bind = dik_to_bind(key)
			   if bind == key_bindings.kCONSOLE then
					local str = strformat(game.translate_string("st_ui_raid_no_console"),text)
					actor_menu.set_msg(1, str, 4)   
					flags.ret_value = false
			   end
			end
		end
	end
end  

function on_game_start()
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("on_before_save_input", on_before_save_input)
	RegisterScriptCallback("on_before_load_input", on_before_load_input)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("on_option_change", on_option_change)
	RegisterScriptCallback("on_before_key_press", on_before_key_press)
end