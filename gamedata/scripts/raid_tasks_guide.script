local gt = game.translate_string
local ltx = ini_file("misc\\task\\tm_raid_tasks.ltx")
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table


-- ============================================
-- ================== (1) Guide ===================
-- ============================================
task_functor.raid_task_guide_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if tsk.stage == 2 then
			local squad = alife_object(active_t[task_id].guide_squad_id)
			local commander = squad and squad.commander_id and level.object_by_id(squad:commander_id())
			if commander and commander.alive and commander:alive() then
				if commander:has_info("npcx_is_companion") then
					local smart = alife_object(active_t[task_id].guide_smart_id)
					return smart and smart.id
				end
				return squad.id
			end
		end
	end

end

task_status_functor.raid_task_guide_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = spawn
	2 = escorted or killed
	3 = completed
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level name
		active_t[task_id].level_name = task_data.level_name

		-- get squad section
		local sec = "raid_guide_" .. task_data.comm .. "_squad"
		active_t[task_id].squad_sec = sec

		active_t[task_id].guide_dead = 0

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return
	end

	-- spawn
	if tsk.stage == 1 and level.name() == active_t[task_id].level_name then
		local squad = raid_utils.spawn_guide_squad(active_t[task_id].squad_sec)

		-- store commander id, squad id and smart to guide
		if squad and squad.commander_id then
			active_t[task_id].guide_squad_id = squad.id
			active_t[task_id].guide_dead = 0
			active_t[task_id].guide_squad_size = raid_utils.get_squad_size(squad.id)

			local smarts_t = raid_utils.find_random_smart(active_t[task_id].level_name, nil, "all")
			for sm_id, _ in pairs(smarts_t) do
				local smart = alife_object(sm_id)
				if smart then
					if db.actor:position():distance_to(smart.position) > 300 then
						active_t[task_id].guide_smart_id = sm_id
					end
				end
			end
		end

		tsk.stage = 2
		return
	end


	if tsk.stage == 2 then

		-- fail if all members died
		if active_t[task_id].guide_dead >= active_t[task_id].guide_squad_size then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end

		-- if we are at smart - remove companions
		local smart = alife_object(active_t[task_id].guide_smart_id)
		local squad = alife_object(active_t[task_id].guide_squad_id)
		if smart and (squad and squad.commander_id) and smart.position:distance_to(squad.position) < 15 then
			local commander = level.object_by_id(squad:commander_id())
			if commander and commander.alive and commander:alive() then
				dialogs_axr_companion.remove_companions_from_squad(db.actor, commander)
				tsk.stage = 3
				return
			end
		end

		-- fail if we return home without escorting
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end

	end


	-- return home
	if tsk.stage == 3 then
		if level.name() == raid_utils.raid_home_level then
			local rew = active_t[task_id].guide_dead > 0
			raid_tasks_main.end_raid_task(task_id, "complete")		-- xcvb reward argument here
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end


-- ============================================
-- ================ (2) Evacuation =================
-- ============================================
task_functor.raid_task_evacuation_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if tsk.stage == 2 and active_t[task_id].evac_alive then
			local se_npc = alife_object(active_t[task_id].evac_id)
	--		local npc = level.object_by_id(active_t[task_id].evac_id)
	--		local is_not_comp = npc and (not npc:has_info("npcx_is_companion"))
			if se_npc then
				return active_t[task_id].evac_id
			end
		end
	end

end

task_status_functor.raid_task_evacuation_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = spawn
	2 = waiting for actor or companion
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level name
		active_t[task_id].level_name = task_data.level_name

		-- store type
		active_t[task_id].typ = task_data.typ

		-- get squad section
		local sec = "raid_evac_" .. task_data.comm .. "_squad"
		active_t[task_id].squad_sec = sec

		-- get smart
		local all_smarts_t = raid_utils.find_random_smart(task_data.level_name, true, "all")
		local smart = raid_utils.find_viable_smart(all_smarts_t, task_data.comm, true)
		local smart_id = smart.id
		active_t[task_id].smart_id = smart_id
		active_t[task_id].smart_name = alife_object(smart_id):name()

		-- add smart id to busy smarts
		raid_tasks_main.raid_busy_smarts_t[smart_id] = true

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return
	end

	-- spawn
	if tsk.stage == 1 and level.name() == active_t[task_id].level_name then
		local squad = raid_simulation.spawn_raid_sim_squad(active_t[task_id].smart_id, active_t[task_id].squad_sec)

		-- store commander id, squad id and set scripted target
		if squad and squad.commander_id then
			squad.scripted_target = active_t[task_id].smart_name
			active_t[task_id].evac_squad_id = squad.id
			active_t[task_id].evac_id = squad:commander_id()
			active_t[task_id].evac_alive = true
		end

		tsk.stage = 2
		return
	end

	-- check companion
	if tsk.stage == 2 then
		local evac_target = level.object_by_id(active_t[task_id].evac_id)
		local evac_alive = active_t[task_id].evac_alive

		-- become comp if actor close
		if evac_target and evac_alive and (not evac_target:has_info("npcx_is_companion")) and db.actor:position():distance_to(evac_target:position()) < 4 then
			dialogs_axr_companion.become_actor_companion(db.actor, evac_target)
		end

		-- fail if dies
		if (not evac_alive) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end

		-- return home
		if level.name() == raid_utils.raid_home_level then

			-- complete if target comp
			if evac_target and evac_target:has_info("npcx_is_companion") then
				raid_tasks_main.end_raid_task(task_id, "complete")
				return
			end

			-- fail if not
			if evac_target and evac_target:has_info("npcx_is_companion") then
				raid_tasks_main.end_raid_task(task_id, "fail")
				return
			end
		end

	end


	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
		end
	end

end


-- ============================================
-- ============================================
function squad_on_npc_death(squad, se_obj, killer)
	local active_t = raid_tasks_main.raid_active_tasks
	for task_id, t in pairs(active_t) do

		-- guide target dies
		if t.guide_squad_id and t.guide_squad_id == squad.id then
			active_t[task_id].guide_dead = active_t[task_id].guide_dead + 1
		end

		-- evac target dies
		if t.evac_id and t.evac_id == se_obj.id then
			active_t[task_id].evac_alive = false
		end

	end
end

function on_game_start()
	RegisterScriptCallback("squad_on_npc_death", squad_on_npc_death)
end