local gt = game.translate_string
local ltx = ini_file("misc\\task\\tm_raid_tasks.ltx")
local ctime_to_t = utils_data.CTime_to_table
local t_to_ctime = utils_data.CTime_from_table

local delivery_sec_t = {		-- item indices
	["in"] = { 1, 2, 3, 4, 5 },
	["out"] = { 6, 7, 8, 9, 10, 11 },
}

-- ============================================
-- ================ (1) Delivery in =================
-- ============================================
task_functor.raid_task_delivery_in_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage
	if not active_t then return end

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if stage == 1 then
			return active_t[task_id].stash_id
		elseif stage == 2 then
			return active_t[task_id].item_id
		end
	end

end

task_status_functor.raid_task_delivery_in_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = delivery process
	2 = quest item dropped
	3 = delivered
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level and stash
		active_t[task_id].level_name = task_data.level_name
		active_t[task_id].stash_id = raid_utils.find_random_stash(task_data.level_name, true) or "No stash id"
		raid_tasks_main.raid_busy_stashes_t[active_t[task_id].stash_id] = true

		-- spawn item and store its id
		local itm_ar = delivery_sec_t["in"]
		local item_sec = "raid_delivery_item_" .. itm_ar[math.random(1, #itm_ar)]
		local item = alife_create_item(item_sec, db.actor)
		active_t[task_id].item_sec = item_sec
		active_t[task_id].item_id = item and item.id or "No item ID"

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return		-- next update just in case
	end

	if tsk.stage == 1 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id then
			-- item in a stash
			if item.parent_id == active_t[task_id].stash_id then
				alife_release(item)
				tsk.stage = 3
				active_t[task_id].item_id = nil
			-- dropped item
			elseif item.parent_id ~= 0 then
				tsk.stage = 2
			end
		end
	end

	if tsk.stage == 2 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 1
		end
	end


	-- complete
	if tsk.stage == 3 then
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "complete")
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end


-- ============================================
-- ================ (2) Delivery out =================
-- ============================================
task_functor.raid_task_delivery_out_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if (tsk.stage == 1 or tsk.stage == 2) then
			return active_t[task_id].item_id
		end
	end

end

task_status_functor.raid_task_delivery_out_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = taking process
	2 = quest item dropped
	3 = taken
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level and stash
		active_t[task_id].level_name = task_data.level_name
		active_t[task_id].stash_id = raid_utils.find_random_stash(task_data.level_name, true) or "No stash id"
		raid_tasks_main.raid_busy_stashes_t[active_t[task_id].stash_id] = true

		-- spawn item in stash and store its id
		local itm_ar = delivery_sec_t["out"]
		local item_sec = "raid_delivery_item_" .. itm_ar[math.random(1, #itm_ar)]
		local se_stash = alife_object(active_t[task_id].stash_id)
		local item = alife_create_item(item_sec, se_stash)
		active_t[task_id].item_sec = item_sec
		active_t[task_id].item_id = item and item.id or "No item ID"

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return		-- next update just in case
	end

	-- item taken
	if tsk.stage == 1 or tsk.stage == 2 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 3
		end
	end

	-- item dropped
	if tsk.stage == 3 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id ~= 0 then
			tsk.stage = 2
		end
	end


	-- complete
	if tsk.stage == 3 then
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "complete")
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end


-- ============================================
-- ============= (3) Delivery out world ===============
-- ============================================
task_functor.raid_task_delivery_out_world_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if (tsk.stage == 1 or tsk.stage == 2) then
			return active_t[task_id].item_id
		end
	end

end

task_status_functor.raid_task_delivery_out_world_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = taking process
	2 = quest item dropped
	3 = taken
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level and smart
		active_t[task_id].level_name = task_data.level_name
		active_t[task_id].smart_id = raid_utils.find_random_smart(task_data.level_name, nil, nil, true) or "No smart id"

		-- spawn item on smart and store its id
		local itm_ar = delivery_sec_t["out"]
		local item_sec = "raid_delivery_item_" .. itm_ar[math.random(1, #itm_ar)]
		local smart = alife_object(active_t[task_id].smart_id)
		local item = alife_create_item(item_sec, { vector():set(smart.position.x, smart.position.y + 3, smart.position.z), smart.m_level_vertex_id, smart.m_game_vertex_id } )
		active_t[task_id].item_sec = item_sec
		active_t[task_id].item_id = item and item.id or "No item ID"

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return		-- next update just in case
	end

	-- item taken
	if tsk.stage == 1 or tsk.stage == 2 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id == 0 then
			tsk.stage = 3
		end
	end

	-- item dropped
	if tsk.stage == 3 then
		local item = alife_object(active_t[task_id].item_id)
		if item and item.parent_id and item.parent_id ~= 0 then
			tsk.stage = 2
		end
	end


	-- complete
	if tsk.stage == 3 then
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "complete")
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end


-- ============================================
-- =============== (4) Delivery mines ================
-- ============================================
task_functor.raid_task_delivery_mines_target_functor = function(task_id,field,p,tsk)
	local active_t = raid_tasks_main.raid_active_tasks
	local stage = tsk and tsk.stage

	if (field == "title") then
		return raid_utils.get_raid_task_title(task_id, stage, 3)
	elseif (field == "descr") then
		return raid_utils.get_raid_task_descr(task_id, stage, 3)
	elseif (field == "target") and stage and stage > 0 and active_t[task_id] then
		if tsk.stage == 1 then
			return active_t[task_id].smart_id
		end
	end

end

task_status_functor.raid_task_delivery_mines_status_functor = function(tsk,task_id)
	local active_t = raid_tasks_main.raid_active_tasks
	local cur_time = game.get_game_time()
	local task_data = raid_tasks_main.get_task_data(task_id)
	if not (task_data and tsk) then return end

	if not tsk.stage then
		tsk.stage = 0
	end

	if tsk.stage > 0 and not active_t[task_id] then
		return
	end

--[[
	0 = setup
	1 = delivering process
	3 = completed
--]]

	-- setup
	if tsk.stage == 0 then
		active_t[task_id] = {}

		-- store level and smart
		active_t[task_id].level_name = task_data.level_name
		active_t[task_id].smart_id = raid_utils.find_random_smart(task_data.level_name) or "No smart id"
		active_t[task_id].mines_placed = false

		-- spawn item and store its id
		local item_sec = "raid_delivery_item_mines"
		local smart = alife_object(active_t[task_id].smart_id)
		local item = alife_create_item(item_sec, db.actor )
		active_t[task_id].item_id = item and item.id or "No item ID"

		-- set timer
		active_t[task_id].start_time = ctime_to_t(cur_time)

		tsk.stage = 1
		return		-- next update just in case
	end

	if tsk.stage == 1 and active_t[task_id].mines_placed then
		tsk.stage = 3
	end


	-- complete
	if tsk.stage == 3 then
		if level.name() == raid_utils.raid_home_level then
			raid_tasks_main.end_raid_task(task_id, "complete")
		end
		return
	end

	-- fail on timer
	if task_data.urgent < 4 then
		local hours = raid_tables.raid_urgency_time[task_data.urgent]
		if cur_time:diffSec(t_to_ctime(active_t[task_id].start_time)) > (hours * 3600) then
			raid_tasks_main.end_raid_task(task_id, "fail")
			return
		end
	end

end

function get_mines_info(obj_id)
	local active_t = raid_tasks_main.raid_active_tasks
	for task_id, t in pairs(active_t) do
		if string.find(task_id, "delivery_mines") and t.item_id == obj_id then
			return { task_id, t.smart_id }
		end
	end
end

function menu_mines(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
	return gt("st_raid_place_mines")
end

function func_mines(obj)
	local active_t = raid_tasks_main.raid_active_tasks
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end

	local task_id = get_mines_info(obj:id())[1]
	local smart_id = get_mines_info(obj:id())[2]
	local smart = alife_object(smart_id)

	if smart and db.actor:position():distance_to(smart.position) < 20 then
		active_t[task_id].mines_placed = true
		alife_release(obj)
		active_t[task_id].item_id = nil
		-- xcvb message about mines placed
	end

	-- xcvb message about the need to be closer
end

Default_name_custom = ui_inventory.UIInventory.Name_Custom
function ui_inventory.UIInventory:Name_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Name_Custom " .. i)
	if i == 9 and get_mines_info(obj:id()) then
		return menu_mines(obj)
	end
	return Default_name_custom(self, obj, bag, temp, i)
end

Default_action_custom = ui_inventory.UIInventory.Action_Custom
function ui_inventory.UIInventory:Action_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Action_Custom " .. i)
	if i == 9 and get_mines_info(obj:id()) then
		func_mines(obj)
		return
	end
	Default_action_custom(self, obj, bag, temp, i)
end